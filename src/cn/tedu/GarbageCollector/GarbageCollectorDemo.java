package cn.tedu.GarbageCollector;
/*
 * 垃圾分代回收机制
 * 		
 * 		栈---代码的执行  用完就立即清除
 * 		方法区 --- 类的信息
 * 		堆 ---无用对象在某个时间进行回收---针对的是堆
 * 		
 * 		java中规定相应类型的数据就要占用固定的内存，C
 * 		语言占用内存不固定，java程序员控制不了内存的管
 * 		理
 * 		在程序 刚启动的时候，会有GC（垃圾回收器）会自动
 * 		检测堆内存的使用情况，一旦发现堆内存的使用率超过
 * 		70%（默认）就通知系统进行垃圾回收
 * 		
 * 		堆（Heap space）
 * 			新生代（Young Generation）
 * 			伊甸园（eden）			eden：from：to = 8:1:1
 * 			幸存区（survivor）
 * 				from space   		
 * 				to space
 * 			老生代（Old Generation）
 * 	对象刚创建的时候先放入新生代的伊甸园区，如果在伊甸园区
 * 	经过一次回收依然存在，那么这个对象就挪到幸存区，在幸存
 * 	区中经过多次回收这个对象依然存在则挪到老生代。在回收的
 * 	时候先回收新生代，如果新生代回收之后的内存足够使用则不
 * 	扫描老生代；如果不够则扫描老生代。老生代的扫描频率要低
 * 	于新生代
 * 		初代回收（针对的是新生代）
 * 		完全回收（针对的是整个区域）
 * 如果老生代的对象突然消失？有可能造成系统崩溃
 * 扩展：对象创建完成之后会先试图放入新生代；如果新生代经过
 * 回收之后也放不开，则直接试图将该对象放入老生代。老生代如
 * 果也放不开，则会出现错误―――――OutOfMemoryError――――
 * 							         内存溢出错误
 */
public class GarbageCollectorDemo {

}
